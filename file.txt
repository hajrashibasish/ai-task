# tests/conftest.py
import os
import sys
import importlib.util
from pathlib import Path
from types import ModuleType
from unittest.mock import MagicMock, patch
import tempfile
import pytest

# -------------------- WGPT path bootstrap (bin/lib or bin/libs) --------------------
def _find_repo_root(start: Path, markers=("wkmai-wgpt-etl", "wgpt-etl")) -> Path:
    parts = start.parts
    idxs = [i for i, p in enumerate(parts) if p in markers]
    if idxs:
        return Path(*parts[: idxs[-1] + 1])
    for p in [start, *start.parents]:
        if (p / "bin" / "lib" / "WGPT").is_dir() or (p / "bin" / "libs" / "WGPT").is_dir():
            return p
    raise RuntimeError(f"Could not locate repo root from: {start}")

def _add_wgpt_parent_to_syspath(current_file: str) -> None:
    here = Path(current_file).resolve()
    repo_root = _find_repo_root(here)
    for cand in (repo_root / "bin" / "lib", repo_root / "bin" / "libs"):
        if (cand / "WGPT").is_dir():
            s = str(cand)
            if s not in sys.path:
                sys.path.insert(0, s)  # parent of WGPT
            return
    raise ImportError("WGPT not found under bin/lib or bin/libs")

_add_wgpt_parent_to_syspath(__file__)

# -------------------- Safe logging.FileHandler shim (prevents FS errors) --------------------
import logging

class _SafeFileHandler(logging.FileHandler):
    """
    Drop-in replacement for logging.FileHandler that:
      1) Creates parent dirs if possible
      2) Falls back to a temp file if target path is not creatable/writable
    """
    def __init__(self, filename, mode='a', encoding=None, delay=False, errors=None):
        target = filename
        try:
            parent = os.path.dirname(os.path.abspath(filename))
            if parent:
                os.makedirs(parent, exist_ok=True)
            # Try opening using base class (this also validates writability if delay is False)
            super().__init__(filename, mode=mode, encoding=encoding, delay=delay, errors=errors)
            return
        except Exception:
            # Fallback to temp
            tmp = os.path.join(tempfile.gettempdir(), os.path.basename(filename) or "edp.log")
            target = tmp
            super().__init__(tmp, mode=mode, encoding=encoding, delay=delay, errors=errors)
        finally:
            # Expose where we actually wrote for debugging (not used by tests unless they read handler.baseFilename)
            self._resolved_filename = target

# Install shim early so basicConfig / FileHandler in imported modules use it
logging.FileHandler = _SafeFileHandler  # type: ignore

# -------------------- KMAI full stub (only if real KMAI is absent) --------------------
def _ensure_kmai_stub():
    if importlib.util.find_spec("KMAI") is not None:
        return  # real KMAI available (e.g., in your VM) – do nothing

    kmai_pkg = ModuleType("KMAI")

    # ---- KMAI.azure ----
    azure_mod = ModuleType("KMAI.azure")
    class AzureDB:
        def __init__(self, *args, **kwargs): pass
        def __enter__(self): return self
        def __exit__(self, exc_type, exc, tb): pass
        def executeQuery(self, *a, **k): return []
        def read_sql(self, *a, **k): return ([], [])
        def execute_insert(self, *a, **k): return None
    class AzureSearchIndex:
        def __init__(self, *args, **kwargs): pass
        def upsert(self, *a, **k): return None
        def search(self, *a, **k): return []
    class AzureADLS:
        def __init__(self, *args, **kwargs): pass
        def upload(self, *a, **k): return None
        def download(self, *a, **k): return b""
        def exists(self, *a, **k): return False
        def listdir(self, *a, **k): return []
    azure_mod.AzureDB = AzureDB
    azure_mod.AzureSearchIndex = AzureSearchIndex
    azure_mod.AzureADLS = AzureADLS

    # ---- KMAI.ingestion ----
    ingestion_mod = ModuleType("KMAI.ingestion")
    class DocumentRetrieval:
        def __init__(self, *args, **kwargs): pass
        def fetch(self, *a, **k): return []
    class Pdf2Markdown:
        def __init__(self, *args, **kwargs): pass
        def convert(self, *a, **k): return "# stub md"
    class Ppt2Markdown:  # <— missing in failures
        def __init__(self, *args, **kwargs): pass
        def convert(self, *a, **k): return "# stub ppt md"
    class Excel2Markdown:
        def __init__(self, *args, **kwargs): pass
        def convert(self, *a, **k): return "# stub table md"
    class TDCertificate:
        def __init__(self, *args, **kwargs): pass
        def validate(self, *a, **k): return True
    class DocumentList:
        def __init__(self, *args, **kwargs): pass
        def get_urls_by_hash(self, *a, **k): return []
        def get_urls(self, *a, **k): return []
        def enrich(self, *a, **k): return []

    ingestion_mod.DocumentRetrieval = DocumentRetrieval
    ingestion_mod.Pdf2Markdown = Pdf2Markdown
    ingestion_mod.Ppt2Markdown = Ppt2Markdown
    ingestion_mod.Excel2Markdown = Excel2Markdown
    ingestion_mod.TDCertificate = TDCertificate
    ingestion_mod.DocumentList = DocumentList

    # ---- KMAI.processing ----
    processing_mod = ModuleType("KMAI.processing")
    class KMAIDocumentProcessing:
        def __init__(self, *args, **kwargs): pass
        def process(self, *a, **k): return None
        def clean_markdown(self, s, *a, **k): return s
        def postprocess(self, s, *a, **k): return s
    class DocumentSplit:
        def __init__(self, *args, **kwargs): pass
        def split(self, *a, **k): return []
    class ArchiveProcessing:  # <— tests import this symbol
        def __init__(self, *args, **kwargs): pass
        def export_document_list(self, *a, **k): return True
        def archive_raw_files(self, *a, **k): return True
        def archive_md_files(self, *a, **k): return True
        def upload_to_adls(self, *a, **k): return True

    processing_mod.KMAIDocumentProcessing = KMAIDocumentProcessing
    processing_mod.DocumentSplit = DocumentSplit
    processing_mod.ArchiveProcessing = ArchiveProcessing

    # ---- KMAI.utilities ----
    utilities_mod = ModuleType("KMAI.utilities")
    def read_config(*args, **kwargs): return {}
    def read_json_config(*args, **kwargs): return {}
    utilities_mod.read_config = read_config
    utilities_mod.read_json_config = read_json_config

    # Wire up the package
    kmai_pkg.azure = azure_mod
    kmai_pkg.ingestion = ingestion_mod
    kmai_pkg.processing = processing_mod
    kmai_pkg.utilities = utilities_mod

    sys.modules["KMAI"] = kmai_pkg
    sys.modules["KMAI.azure"] = azure_mod
    sys.modules["KMAI.ingestion"] = ingestion_mod
    sys.modules["KMAI.processing"] = processing_mod
    sys.modules["KMAI.utilities"] = utilities_mod

_ensure_kmai_stub()

# -------------------- usecase.prod.common.dataclasses stub (Bottlenose) --------------------
def _ensure_usecase_stub():
    if importlib.util.find_spec("usecase") is not None:
        return

    usecase_pkg = ModuleType("usecase")
    prod_pkg = ModuleType("usecase.prod")
    common_pkg = ModuleType("usecase.prod.common")
    dataclasses_mod = ModuleType("usecase.prod.common.dataclasses")

    # Extremely permissive dataclasses; tests can access any fields safely.
    class IngestionConfig:
        def __init__(self, **kwargs):
            for k, v in kwargs.items():
                setattr(self, k, v)
    class DocumentWithMetadata:
        def __init__(self, document: str = "", metadata: dict = None, **kwargs):
            self.document = document
            self.metadata = metadata or {}
            for k, v in kwargs.items():
                setattr(self, k, v)

    dataclasses_mod.IngestionConfig = IngestionConfig
    dataclasses_mod.DocumentWithMetadata = DocumentWithMetadata

    sys.modules["usecase"] = usecase_pkg
    sys.modules["usecase.prod"] = prod_pkg
    sys.modules["usecase.prod.common"] = common_pkg
    sys.modules["usecase.prod.common.dataclasses"] = dataclasses_mod

_ensure_usecase_stub()

# -------------------- pyodbc shim --------------------
class _MockCursor:
    def execute(self, *a, **k): pass
    def fetchone(self): return ("15.0.2000.5",)
    def setinputsizes(self, *a, **k): return
    @property
    def description(self): return [("ProductVersion", None, None, None, None)]
    def rowcount(self): return
    def close(self): pass

class _MockConnection:
    def cursor(self): return _MockCursor()
    def add_output_converter(self, *a, **k): pass
    def rollback(self): pass
    def commit(self): pass
    def getinfo(self, info):
        if info == 2:  # SQL_DBMS_VER
            return "15.0.2000.5"

class _MockImporter:
    def find_spec(self, fullname, path=None, target=None):
        if fullname == "pyodbc":
            mod = ModuleType("pyodbc")
            mod.__loader__ = MagicMock()
            mod.__package__ = ""
            mod.__spec__ = MagicMock()
            mod.version = "4.0.30"
            mod.connect = MagicMock(return_value=_MockConnection())
            mod.paramstyle = "qmark"
            mod.Cursor = _MockCursor
            mod.Error = Exception
            mod.ProgrammingError = Exception
            mod.SQL_DBMS_VER = 2
            mod.NUMBER = 1
            mod.SQL_VARCHAR = "12"
            mod.DATETIME = "93"
            sys.modules[fullname] = mod
            return mod.__spec__
        return None

sys.meta_path.insert(0, _MockImporter())

# -------------------- helpers & fixtures --------------------
def get_test_file_path(current_file, target_folder="wkmai-wgpt-etl"):
    absolute_path = os.path.abspath(current_file)
    parts = absolute_path.split(os.sep)
    if target_folder not in parts:
        raise ValueError(f"{target_folder} not in path: {absolute_path}")
    idx = len(parts) - 1 - parts[::-1].index(target_folder)
    out = parts[: idx + 1]
    if "tests" in parts:
        out += parts[parts.index("tests") + 1 :]
    else:
        out += parts[idx + 1 :]
    out = [p[5:] if p.startswith("test_") else p for p in out]
    return os.sep.join(out)

@pytest.fixture
def import_module():
    def _import_module(module_name, file_path):
        spec = importlib.util.spec_from_file_location(module_name, get_test_file_path(file_path))
        mod = importlib.util.module_from_spec(spec)
        sys.modules[module_name] = mod
        spec.loader.exec_module(mod)
        return mod
    return _import_module

@pytest.fixture(scope="session", autouse=True)
def mock_os_environ():
    with patch.dict(os.environ, {
        "KMAI_VERSION": os.environ.get("KMAI_VERSION", "dev"),
        "PROJECT_REPO": os.environ.get("PROJECT_REPO", "wgpt-etl"),
        "ROOT_DIR": os.environ.get("ROOT_DIR", "/app1/ingestion"),
        "KMAI_REPO": os.environ.get("KMAI_REPO", "kmai"),
        "INGESTION_CONFIG_FILE": os.environ.get("INGESTION_CONFIG_FILE", "wgpt-etl-dev.json"),
    }, clear=False):
        yield

@pytest.fixture
def mock_db():
    db = MagicMock()
    db.executeQuery = MagicMock()
    db.read_sql = MagicMock(return_value=([], []))
    db.execute_insert = MagicMock()
    db.__enter__.return_value = db
    return db
