# tests/conftest.py
import os
import sys
import importlib.util
from pathlib import Path
from types import ModuleType
from unittest.mock import MagicMock, patch
import pytest

# -------------------- Repo / path bootstrap --------------------
def _find_repo_root(start: Path, markers=("wkmai-wgpt-etl", "wgpt-etl")) -> Path:
    parts = start.parts
    idxs = [i for i, p in enumerate(parts) if p in markers]
    if idxs:
        return Path(*parts[: idxs[-1] + 1])
    for p in [start, *start.parents]:
        if (p / "bin" / "lib" / "WGPT").is_dir() or (p / "bin" / "libs" / "WGPT").is_dir():
            return p
    raise RuntimeError(f"Could not locate repo root from: {start}")

def _wire_paths(current_file: str) -> None:
    """Make WGPT and repo/bin (for usecase) importable without touching main scripts."""
    here = Path(current_file).resolve()
    repo_root = _find_repo_root(here)

    # 1) WGPT (supports both bin/lib and bin/libs)
    for cand in (repo_root / "bin" / "lib", repo_root / "bin" / "libs"):
        if (cand / "WGPT").is_dir():
            s = str(cand)
            if s not in sys.path:
                sys.path.insert(0, s)  # parent of WGPT
            break

    # 2) repo/bin so that "usecase" and other first-party pkgs under bin/ are importable
    bin_dir = str(repo_root / "bin")
    if bin_dir not in sys.path:
        sys.path.insert(0, bin_dir)

_wire_paths(__file__)

# -------------------- KMAI full stub (only if real KMAI is absent) --------------------
def _ensure_kmai_stub():
    spec = importlib.util.find_spec("KMAI")
    if spec is not None:
        return  # real KMAI exists – do nothing

    kmai_pkg = ModuleType("KMAI")

    # ---- KMAI.azure ----
    azure_mod = ModuleType("KMAI.azure")

    class AzureDB:
        def __init__(self, *args, **kwargs): pass
        def __enter__(self): return self
        def __exit__(self, exc_type, exc, tb): pass
        def executeQuery(self, *a, **k): return []
        def read_sql(self, *a, **k): return ([], [])
        def execute_insert(self, *a, **k): return None

    class AzureSearchIndex:
        def __init__(self, *args, **kwargs): pass
        def upsert(self, *a, **k): return None
        def search(self, *a, **k): return []

    class AzureADLS:
        def __init__(self, *args, **kwargs): pass
        def upload(self, *a, **k): return None
        def download(self, *a, **k): return b""
        def exists(self, *a, **k): return False
        def listdir(self, *a, **k): return []

    azure_mod.AzureDB = AzureDB
    azure_mod.AzureSearchIndex = AzureSearchIndex
    azure_mod.AzureADLS = AzureADLS

    # ---- KMAI.ingestion ----
    ingestion_mod = ModuleType("KMAI.ingestion")

    class DocumentRetrieval:
        def __init__(self, *args, **kwargs): pass
        def fetch(self, *a, **k): return []

    class Pdf2Markdown:
        def __init__(self, *args, **kwargs): pass
        def convert(self, *a, **k): return "# stub md"

    class Excel2Markdown:
        def __init__(self, *args, **kwargs): pass
        def convert(self, *a, **k): return "# stub table md"

    class Ppt2Markdown:  # needed by bin/03_doc_conversion.py
        def __init__(self, *args, **kwargs): pass
        def convert(self, *a, **k): return "# stub ppt md"

    class DocumentList:
        def __init__(self, *args, **kwargs): pass
        def get_urls_by_hash(self, *a, **k): return []
        def get_urls(self, *a, **k): return []
        def enrich(self, *a, **k): return []

    class TDCertificate:
        def __init__(self, *args, **kwargs): pass
        def validate(self, *a, **k): return True

    ingestion_mod.DocumentRetrieval = DocumentRetrieval
    ingestion_mod.Pdf2Markdown = Pdf2Markdown
    ingestion_mod.Excel2Markdown = Excel2Markdown
    ingestion_mod.Ppt2Markdown = Ppt2Markdown
    ingestion_mod.DocumentList = DocumentList
    ingestion_mod.TDCertificate = TDCertificate

    # ---- KMAI.processing ----
    processing_mod = ModuleType("KMAI.processing")

    class KMAIDocumentProcessing:
        def __init__(self, *args, **kwargs): pass
        def process(self, *a, **k): return None
        def clean_markdown(self, s): return s
        def postprocess(self, s): return s

    class DocumentSplit:
        def __init__(self, *args, **kwargs): pass
        def split(self, *a, **k): return []

    class ArchiveProcessing:  # required by archive tests
        def __init__(self, *args, **kwargs): pass
        def export_document_list(self, *a, **k): return None
        def archive_raw_files(self, *a, **k): return None
        def archive_md_files(self, *a, **k): return None
        def upload_to_adls(self, *a, **k): return None
        def check_index(self, *a, **k): return True

    processing_mod.KMAIDocumentProcessing = KMAIDocumentProcessing
    processing_mod.DocumentSplit = DocumentSplit
    processing_mod.ArchiveProcessing = ArchiveProcessing

    # ---- KMAI.utilities ----
    utilities_mod = ModuleType("KMAI.utilities")

    def read_config(*args, **kwargs):
        return {}

    def read_json_config(*args, **kwargs):
        return {}

    utilities_mod.read_config = read_config
    utilities_mod.read_json_config = read_json_config

    # Wire up the package
    kmai_pkg.azure = azure_mod
    kmai_pkg.ingestion = ingestion_mod
    kmai_pkg.processing = processing_mod
    kmai_pkg.utilities = utilities_mod

    sys.modules["KMAI"] = kmai_pkg
    sys.modules["KMAI.azure"] = azure_mod
    sys.modules["KMAI.ingestion"] = ingestion_mod
    sys.modules["KMAI.processing"] = processing_mod
    sys.modules["KMAI.utilities"] = utilities_mod

_ensure_kmai_stub()

# -------------------- pyodbc shim --------------------
class _MockCursor:
    def execute(self, *a, **k): pass
    def fetchone(self): return ("15.0.2000.5",)
    def setinputsizes(self, *a, **k): return
    @property
    def description(self): return [("ProductVersion", None, None, None, None)]
    def rowcount(self): return
    def close(self): pass

class _MockConnection:
    def cursor(self): return _MockCursor()
    def add_output_converter(self, *a, **k): pass
    def rollback(self): pass
    def commit(self): pass
    def getinfo(self, info):
        if info == 2:  # SQL_DBMS_VER
            return "15.0.2000.5"

class _MockImporter:
    def find_spec(self, fullname, path=None, target=None):
        if fullname == "pyodbc":
            mod = ModuleType("pyodbc")
            mod.__loader__ = MagicMock()
            mod.__package__ = ""
            mod.__spec__ = MagicMock()
            mod.version = "4.0.30"
            mod.connect = MagicMock(return_value=_MockConnection())
            mod.paramstyle = "qmark"
            mod.Cursor = _MockCursor
            mod.Error = Exception
            mod.ProgrammingError = Exception
            mod.SQL_DBMS_VER = 2
            mod.NUMBER = 1
            mod.SQL_VARCHAR = "12"
            mod.DATETIME = "93"
            sys.modules[fullname] = mod
            return mod.__spec__
        return None

sys.meta_path.insert(0, _MockImporter())

# -------------------- helpers & fixtures --------------------
def get_test_file_path(current_file, target_folder="wkmai-wgpt-etl"):
    absolute_path = os.path.abspath(current_file)
    parts = absolute_path.split(os.sep)
    if target_folder not in parts:
        raise ValueError(f"{target_folder} not in path: {absolute_path}")
    idx = len(parts) - 1 - parts[::-1].index(target_folder)
    out = parts[: idx + 1]
    if "tests" in parts:
        out += parts[parts.index("tests") + 1 :]
    else:
        out += parts[idx + 1 :]
    out = [p[5:] if p.startswith("test_") else p for p in out]
    return os.sep.join(out)

@pytest.fixture
def import_module():
    def _import_module(module_name, file_path):
        spec = importlib.util.spec_from_file_location(module_name, get_test_file_path(file_path))
        mod = importlib.util.module_from_spec(spec)
        sys.modules[module_name] = mod
        spec.loader.exec_module(mod)
        return mod
    return _import_module

@pytest.fixture(scope="session", autouse=True)
def mock_os_environ():
    # Provide defaults but let CI override via env
    env = {
        "KMAI_VERSION": os.environ.get("KMAI_VERSION", "1.0.4"),
        "PROJECT_REPO": os.environ.get("PROJECT_REPO", "wgpt-etl"),
        "ROOT_DIR": os.environ.get("ROOT_DIR", "/app1/ingestion"),
        "KMAI_REPO": os.environ.get("KMAI_REPO", "kmai-etl"),
    }
    with patch.dict(os.environ, env, clear=False):
        # Ensure log dir exists so logging.FileHandler doesn’t explode
        logs_dir = Path(os.environ["ROOT_DIR"]) / os.environ["PROJECT_REPO"] / "logs"
        logs_dir.mkdir(parents=True, exist_ok=True)
        yield

@pytest.fixture(scope="session", autouse=True)
def safe_locale():
    # Fallback to "C" locale if requested one isn’t installed in runner
    import locale
    orig = locale.setlocale
    def _safe_setlocale(category, loc=None):
        try:
            return orig(category, loc)
        except locale.Error:
            return orig(category, "C")
    # Monkeypatch in place (no Mock) for correctness
    saved = locale.setlocale
    locale.setlocale = _safe_setlocale
    try:
        yield
    finally:
        locale.setlocale = saved

@pytest.fixture(scope="session", autouse=True)
def patch_wgpt_document_processing():
    # If certain NACO helpers aren’t present in WGPT.DocumentProcessing, provide benign pass-throughs.
    try:
        import WGPT
        from WGPT import document_processing as _dp
        cls = getattr(_dp, "DocumentProcessing", None)
        if not cls:
            return
        def _id(self, s): return s
        for name in ("naco_doc_preprocess", "naco_doc_basic_clean_html", "naco_doc_post_clean_md"):
            if not hasattr(cls, name):
                setattr(cls, name, _id)
    except Exception:
        # Don’t break test discovery if WGPT isn’t importable here; other fixtures will handle pathing
        pass

@pytest.fixture
def mock_db():
    db = MagicMock()
    db.executeQuery = MagicMock()
    db.read_sql = MagicMock(return_value=([], []))
    db.execute_insert = MagicMock()
    db.__enter__.return_value = db
    return db
