def test_update_document_change_history_with_and_without_hash_changes(load_module):
    mock_db = MagicMock()

    # Case 1: No hash_changes (None)
    load_module.update_document_change_history(mock_db, hash_changes=None, etl_schema="etl")
    assert mock_db.executeQuery.call_count == 2  # insert + update inactive

    mock_db.reset_mock()

    # Case 2: With valid hash_changes
    hash_changes = {
        "doc1": {"old_hash": "abc", "new_hash": "xyz"},
        "doc2": {"old_hash": None, "new_hash": "xyz"}  # should be filtered
    }

    load_module.update_document_change_history(mock_db, hash_changes=hash_changes, etl_schema="etl")
    assert mock_db.executeQuery.call_count == 4  # 2 for insert/update + 2 for hash changes


def test_main_loop_handles_empty_url_info(load_module):
    mock_db = MagicMock()
    mock_doc_list = MagicMock()
    mock_doc_list.__enter__.return_value.get_urls_by_hash.return_value = {}

    with patch.object(load_module, "AzureDB", return_value=mock_db), \
         patch.object(load_module, "DocumentList", return_value=mock_doc_list):
        load_module.main_loop()  # Should complete without exceptions


def test_main_loop_reads_meta_file(load_module):
    mock_db = MagicMock()
    dummy_json = {
        "http://example.com/doc1": {
            "filename": "file1", "hash": "abc123"
        }
    }

    mock_doc_list = MagicMock()
    mock_doc_list.__enter__.return_value.get_urls_by_hash.return_value = {
        "classification": {
            "language": {
                "file1": {
                    "url": "http://example.com/doc1",
                    "hash_256": "abc123"
                }
            }
        }
    }

    with patch("builtins.open", mock_open(read_data=json.dumps(dummy_json))) as m, \
         patch.object(load_module, "AzureDB", return_value=mock_db), \
         patch.object(load_module, "DocumentList", return_value=mock_doc_list), \
         patch.object(load_module, "os") as mock_os:

        mock_os.walk.return_value = [
            ("/output/classification/language", [], ["file1.txt"])
        ]
        mock_os.path.splitext = os.path.splitext
        mock_os.remove = MagicMock()
        mock_os.path.exists.return_value = True

        load_module.main_loop()

    m.assert_any_call("/output/classification/language/file_download_meta.json", "r")


def test_main_loop_handles_none_url_key(load_module):
    mock_db = MagicMock()
    dummy_json = {
        "http://example.com/abc": {
            "filename": "file1", "hash": "abc123"
        }
    }

    mock_doc_list = MagicMock()
    mock_doc_list.__enter__.return_value.get_urls_by_hash.return_value = {
        "classification": {
            "language": {
                None: {
                    "url": "http://example.com/abc",
                    "hash_256": "abc123"
                }
            }
        }
    }

    with patch("builtins.open", mock_open(read_data=json.dumps(dummy_json))), \
         patch.object(load_module, "AzureDB", return_value=mock_db), \
         patch.object(load_module, "DocumentList", return_value=mock_doc_list), \
         patch.object(load_module, "os") as mock_os:

        mock_os.walk.return_value = [
            ("/output/classification/language", [], ["file1.txt"])
        ]
        mock_os.path.splitext = os.path.splitext
        mock_os.remove = MagicMock()

        load_module.main_loop()


def test_main_loop_removes_unwanted_files_and_dumps_required(load_module):
    mock_db = MagicMock()
    file_meta = {
        "http://example.com/doc1": {
            "filename": "file1", "hash": "abc123"
        }
    }

    mock_doc_list = MagicMock()
    mock_doc_list.__enter__.return_value.get_urls_by_hash.return_value = {
        "classification": {
            "language": {
                "file1": {
                    "url": "http://example.com/doc1",
                    "hash_256": "abc123"
                }
            }
        }
    }

    with patch("builtins.open", mock_open(read_data=json.dumps(file_meta))) as m, \
         patch.object(load_module, "AzureDB", return_value=mock_db), \
         patch.object(load_module, "DocumentList", return_value=mock_doc_list), \
         patch.object(load_module, "os") as mock_os, \
         patch("json.dump") as mock_json_dump:

        mock_os.walk.return_value = [
            ("/output/classification/language", [], ["file1.txt"])
        ]
        mock_os.path.splitext = os.path.splitext
        mock_os.remove = MagicMock()

        load_module.main_loop()

    mock_os.remove.assert_called_once()
    mock_json_dump.assert_called_once()
