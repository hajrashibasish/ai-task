import pytest
from unittest.mock import patch, MagicMock
import os


@pytest.fixture
def load_module(import_module):
    """Helper function to import the checkdeltafiles module with mocked os.environ."""
    os.environ["KMAI_VERSION"] = "dev"
    os.environ["PROJECT_REPO"] = "wgpt-etl"
    os.environ["ROOT_DIR"] = "/app1/ingestion"
    os.environ["KMAI_REPO"] = "kmai"
    os.environ["INGESTION_CONFIG_FILE"] = "wgpt-etl-dev.json"

    return import_module("checkdeltafiles", os.path.abspath(__file__))


def test_process_check_delta_files(load_module):
    mock_db_handle = MagicMock()
    mock_doc_list = MagicMock()
    mock_doc_list.get_urls_by_hash.return_value = {
        "classification": {"language": {"file1": {"hash_256": "abc123"}}}
    }

    # Configure context manager behavior
    mock_doc_list.__enter__.return_value = mock_doc_list

    with patch.object(load_module, "DocumentList", return_value=mock_doc_list):
        result = load_module.process_check_delta_files(
            classification="classification",
            language="language",
            db_handle=mock_db_handle,
            etl_schema=None
        )

    assert result == {"classification": {"language": {"file1": {"hash_256": "abc123"}}}}


@patch("builtins.open", new_callable=MagicMock)
def test_main_loop_executes_without_errors(mock_open, load_module):
    # Patch file system
    mock_os = MagicMock()
    mock_os.walk.return_value = [
        ("/tmp/output/internal/en", [], ["file1.pdf", "file2.meta.json"])
    ]
    mock_os.remove = MagicMock()
    mock_os.path.splitext = os.path.splitext

    # Patch DocumentList
    mock_doc_list_instance = MagicMock()
    mock_doc_list_instance.get_urls_by_hash.return_value = {
        "internal": {
            "en": {
                "file1": {
                    "hash_256": "abc123",
                    "url": "http://example.com/file1"
                }
            }
        }
    }

    mock_doc_list = MagicMock(return_value=mock_doc_list_instance)

    # Patch config loader
    mock_read_config = MagicMock(return_value={
        "sql_db": {
            "server_name": "test_server",
            "db_name": "test_db",
            "etl_schema": "etl"
        },
        "credentials": {"object_id": "test_object_id"},
        "processing": {
            "log_dir": "/tmp/logs",
            "output_dir": "/tmp/output"
        },
        "document_scopes": {
            "classification": ["internal"],
            "language": ["en"],
            "document_change_history": False
        }
    })

    # Patch AzureDB context
    mock_azure_db = MagicMock()
    mock_azure_db.__enter__.return_value = mock_azure_db

    with patch.object(load_module, "os", mock_os), \
         patch.object(load_module, "WGPT") as mock_wgpt, \
         patch.object(load_module, "DocumentList", mock_doc_list), \
         patch.object(load_module, "AzureDB", return_value=mock_azure_db):

        mock_wgpt.Utilities.read_config = mock_read_config

        load_module.main_loop()  # This should now run without error

    # Confirm required_files_meta.json is attempted to be written
    mock_open.assert_any_call("/tmp/output/internal/en/required_files_meta.json", "w")
