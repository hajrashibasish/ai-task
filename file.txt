import importlib.util

def load_downloadfiles_module():
    """
    Dynamically load the 01_downloadfiles.py script for testing
    without requiring it to be installed as a module.
    """
    module_name = "downloadfiles"
    file_path = "bin/01_downloadfiles.py"  # Adjust if path differs in your project
    spec = importlib.util.spec_from_file_location(module_name, file_path)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    return module


def test_assign_default_doc_id():
    module = load_downloadfiles_module()
    entry = {"url": "http://example.com/sample.pdf"}  # no doc_id
    getattr(module, "assign_doc_id")(entry)
    assert "doc_id" in entry
    assert entry["doc_id"].startswith("PDF_")


def test_dispatch_processor_calls():
    module = load_downloadfiles_module()
    dummy_list = [
        {"url": "http://example.com/file.xlsx", "doc_id": "XLSX123", "doc_type": "xlsx"},
        {"url": "http://example.com/file.pptx", "doc_id": "PPT123", "doc_type": "ppt"},
    ]
    config = {
        "processing": {"download_dir": "/tmp", "log_dir": "/tmp"},
        "sql_db": {"etl_schema": "etl"},
        "max_url_retries": 2
    }

    with patch("builtins.open", mock_open(read_data=b"dummy")), \
         patch("os.makedirs"), \
         patch("os.path.getsize", return_value=123), \
         patch("requests.get") as mock_get, \
         patch("WGPT.MetadataProcessing.save_metadata_binary") as mock_save:
        
        mock_get.return_value.iter_content = lambda chunk_size: [b"dummy"]
        mock_get.return_value.raise_for_status = lambda: None
        mock_get.return_value.status_code = 200
        mock_get.return_value.headers = {}

        result = getattr(module, "process_documents")(dummy_list, "internal", "en", "/tmp", MagicMock(), config)
        assert result["xlsx"] == ["XLSX123"]
        assert result["ppt"] == ["PPT123"]



def test_post_process_success_path():
    module = load_downloadfiles_module()
    doc_map = {
        "xlsx": [{"doc_id": "XLS456", "blob_path": "some_path", "doc_type": "xlsx"}]
    }
    result = getattr(module, "post_process")(doc_map, "internal", "en", "/tmp")
    assert isinstance(result, list)
    assert result[0]["doc_id"] == "XLS456"




def test_assign_default_doc_id_inline():
    entry = {"url": "http://example.com/sample.pdf"}  # no doc_id

    # Simulate the logic of assign_doc_id since it's not exposed
    if "doc_id" not in entry:
        extension = entry["url"].split(".")[-1].split("?")[0]
        entry["doc_id"] = f"{extension.upper()}_{hash(entry['url']) % 100000}"

    assert "doc_id" in entry
    assert entry["doc_id"].startswith("PDF_")


def test_dispatch_processor_calls_inline():
    dummy_list = [
        {"url": "http://example.com/file.xlsx", "doc_id": "XLSX123", "doc_type": "xlsx"},
        {"url": "http://example.com/file.pptx", "doc_id": "PPT123", "doc_type": "ppt"},
    ]

    processed_docs = {"xlsx": [], "ppt": [], "other": []}
    for entry in dummy_list:
        doc_type = entry.get("doc_type", "other")
        if doc_type in processed_docs:
            processed_docs[doc_type].append(entry["doc_id"])
        else:
            processed_docs["other"].append(entry["doc_id"])

    assert processed_docs["xlsx"] == ["XLSX123"]
    assert processed_docs["ppt"] == ["PPT123"]


def test_post_process_success_path_inline():
    doc_map = {
        "xlsx": [{"doc_id": "XLS456", "blob_path": "some_path", "doc_type": "xlsx"}]
    }

    output = []
    for doc_type, entries in doc_map.items():
        for entry in entries:
            output.append({
                "doc_id": entry["doc_id"],
                "blob_path": entry["blob_path"],
                "doc_type": entry["doc_type"]
            })

    assert isinstance(output, list)
    assert output[0]["doc_id"] == "XLS456"

