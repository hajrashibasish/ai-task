def main_loop():
    config = WGPT.Utilities.read_config()
    server_name = config['sql_db']['server_name']
    db_name = config['sql_db']['db_name']
    etl_schema = config['sql_db']['etl_schema']
    object_id = config['credentials']['object_id']
    document_scopes = config['document_scopes']

    azure_loggers = [
        "azure.identity._credentials.managed_identity",
        "azure.core.pipeline.policies.http_logging_policy"
    ]
    for azl in azure_loggers:
        azlogger = logging.getLogger(azl)
        azlogger.setLevel(logging.ERROR)

    logging.basicConfig(filename=f"{log_file_path}", format="%(levelname)s:%(asctime)s:%(name)s:[DocConversion] %(message)s", level=logging.INFO)

    logger = logging.getLogger("__doc_conversion__")

    for classification in document_scopes.get("classification"):
        for language in document_scopes.get("language"):
            process_doc_conversion(language, classification, logger)


if __name__ == "__main__":
    main_loop()






import pytest
from unittest.mock import patch, MagicMock
import os


@pytest.fixture
def load_module(import_module):
    """Helper to load the doc_conversion module with mocked env."""
    os.environ["KMAI_VERSION"] = "dev"
    os.environ["PROJECT_REPO"] = "wgpt-etl"
    os.environ["ROOT_DIR"] = "/app1/ingestion"
    os.environ["KMAI_REPO"] = "kmai"
    os.environ["INGESTION_CONFIG_FILE"] = "wgpt-etl-dev.json"
    return import_module("doc_conversion", os.path.abspath(__file__))


def test_process_doc_conversion_html(load_module):
    logger = MagicMock()
    config_mock = {
        "processing": {
            "output_dir": "/tmp/output",
            "md_dir": "/tmp/md"
        },
        "sql_db": {
            "etl_schema": "etl",
            "server_name": "srv",
            "db_name": "db"
        },
        "credentials": {
            "object_id": "xyz"
        },
        "document_scopes": {
            "classification": ["internal"],
            "language": ["en"],
            "filter_columns": {"key": "value"}
        },
        "failed_document_threshold_pct": 1.0
    }

    urls_mock = {
        "internal": {
            "en": {
                "http://example.com/doc1.html": {"doc_id": "doc1"}
            }
        }
    }

    os_walk_return = [
        ("/tmp/output/internal/en", [], ["doc1.html"])
    ]

    with patch.object(load_module.WGPT.Utilities, "read_config", return_value=config_mock), \
         patch.object(load_module, "retrieve_url_list", return_value=urls_mock), \
         patch.object(load_module, "os") as mock_os, \
         patch.object(load_module, "process_html_to_markdown", return_value={"status": "Successful"}):
        mock_os.walk.return_value = os_walk_return
        mock_os.path.exists.return_value = True
        mock_os.remove = MagicMock()
        mock_os.makedirs = MagicMock()
        result = load_module.process_doc_conversion("en", "internal", logger)
        assert result is not None


@patch("builtins.open", new_callable=MagicMock)
def test_process_html_to_markdown_success(mock_open, load_module):
    fake_text = "<html><body><h1>Hello</h1></body></html>"
    fake_output = "## Hello"
    logger = MagicMock()

    mock_fd = MagicMock()
    mock_fd.read.return_value = fake_text
    mock_open.return_value.__enter__.side_effect = [mock_fd, MagicMock()]
    dp_mock = MagicMock()
    dp_mock.run_pipeline.return_value = fake_output

    with patch.object(load_module, "DocumentProcessing", return_value=dp_mock):
        result = load_module.process_html_to_markdown("/tmp/file.html", "/tmp", "en", {})
        assert result["status"] == "Successful"
        assert "document_length" in result


def test_process_pdf_to_markdown(load_module):
    config = {
        "credentials": {"client_id": "abc"},
        "open_ai": {
            "gpt_4o_model": "gpt",
            "endpoint_url": "https://xyz",
            "openai_api_version": "v1",
            "pdf_conversion_prompt": "convert",
            "pdf_conversion_dpi": 300
        }
    }
    dp_mock = MagicMock()
    dp_mock.run_pipeline.return_value = "PDF to MD content"
    with patch.object(load_module, "DocumentProcessing", return_value=dp_mock):
        result = load_module.process_pdf_to_markdown(config, "/tmp/doc.pdf", "/tmp", {})
        assert result["document_length"] > 0


def test_process_excel_to_markdown(load_module):
    config = {}
    dp_mock = MagicMock()
    dp_mock.run_pipeline.return_value = "Excel to Markdown"
    with patch.object(load_module, "DocumentProcessing", return_value=dp_mock):
        result = load_module.process_excel_to_markdown(config, "/tmp/excel.xlsx", "/tmp", {})
        assert result["document_length"] > 0


def test_process_ppt_to_markdown(load_module):
    return_val = {}
    ppt_mock = MagicMock()
    ppt_mock.convert.return_value = ("/tmp/doc.md", 1000)
    with patch.object(load_module, "Ppt2Markdown", return_value=ppt_mock):
        result = load_module.process_ppt_to_markdown("/tmp/file.pptx", "/tmp", return_val)
        assert result["status"] == "Successful"
        assert result["document_length"] == 1000










====================



def test_process_doc_conversion_html(load_module):
    logger = MagicMock()

    config_mock = {
        "processing": {
            "output_dir": "/tmp/output",
            "md_dir": "/tmp/md"
        },
        "sql_db": {
            "etl_schema": "etl",
            "server_name": "srv",
            "db_name": "db"
        },
        "credentials": {
            "object_id": "xyz"
        },
        "document_scopes": {
            "classification": ["internal"],
            "language": ["en"],
            "filter_columns": {"key": "value"}
        },
        "failed_document_threshold_pct": 1.0
    }

    urls_mock = {
        "internal": {
            "en": {
                "http://example.com/doc1.html": {"doc_id": "doc1"}
            }
        }
    }

    os_walk_return = [
        ("/tmp/output/internal/en", [], ["doc1.html", "file.meta.json"])
    ]

    with patch.object(load_module.WGPT.Utilities, "read_config", return_value=config_mock), \
         patch.object(load_module, "retrieve_url_list", return_value=urls_mock), \
         patch.object(load_module, "os") as mock_os, \
         patch.object(load_module, "process_html_to_markdown", return_value={"status": "Successful"}) as mock_html:

        mock_os.walk.return_value = os_walk_return
        mock_os.path.exists.return_value = True
        mock_os.remove = MagicMock()
        mock_os.makedirs = MagicMock()
        mock_os.path.splitext = os.path.splitext

        result = load_module.process_doc_conversion("en", "internal", logger)

        # âœ… Final assertion
        assert result == {"doc1.html": {"status": "Successful"}}
        mock_html.assert_called_once()
