import os
import sys
import importlib.util
import logging
from pathlib import Path
from types import ModuleType
from dataclasses import dataclass, field
from typing import Any, Dict
from unittest.mock import MagicMock, patch
import pytest

# ======================= repo / path bootstrap =======================
def _find_repo_root(start: Path, markers=("wkmai-wgpt-etl", "wgpt-etl")) -> Path:
    parts = start.parts
    idxs = [i for i, p in enumerate(parts) if p in markers]
    if idxs:
        return Path(*parts[: idxs[-1] + 1])
    for p in [start, *start.parents]:
        if (p / "bin" / "lib" / "WGPT").is_dir() or (p / "bin" / "libs" / "WGPT").is_dir():
            return p
    raise RuntimeError(f"Could not locate repo root from: {start}")

def _wire_paths(current_file: str) -> Path:
    here = Path(current_file).resolve()
    repo_root = _find_repo_root(here)

    # WGPT under bin/lib or bin/libs
    for cand in (repo_root / "bin" / "lib", repo_root / "bin" / "libs"):
        if (cand / "WGPT").is_dir():
            s = str(cand)
            if s not in sys.path:
                sys.path.insert(0, s)
            break

    # repo/bin (for 'usecase' and other first-party pkgs)
    bin_dir = str(repo_root / "bin")
    if bin_dir not in sys.path:
        sys.path.insert(0, bin_dir)

    return repo_root

_REPO_ROOT = _wire_paths(__file__)

# ======================= safe FileHandler ============================
class _SafeFileHandler(logging.FileHandler):
    def __init__(self, filename, *args, **kwargs):
        try:
            Path(filename).parent.mkdir(parents=True, exist_ok=True)
        except Exception:
            pass
        super().__init__(filename, *args, **kwargs)

# Install globally so any module using logging gets this behavior
logging.FileHandler = _SafeFileHandler  # type: ignore[assignment]

# ======================= KMAI shim / stub ===========================
def _ensure_kmai_ok():
    spec = importlib.util.find_spec("KMAI")
    if spec is None:
        # Full stub
        kmai_pkg = ModuleType("KMAI")

        # azure
        azure_mod = ModuleType("KMAI.azure")
        class AzureDB:
            def __init__(self, *_, **__): ...
            def __enter__(self): return self
            def __exit__(self, *a): ...
            def executeQuery(self, *a, **k): return []
            def read_sql(self, *a, **k): return ([], [])
            def execute_insert(self, *a, **k): return None
        class AzureSearchIndex:
            def __init__(self, *_, **__): ...
            def upsert(self, *a, **k): ...
            def search(self, *a, **k): return []
        class AzureADLS:
            def __init__(self, *_, **__): ...
            def upload(self, *a, **k): ...
            def download(self, *a, **k): return b""
            def exists(self, *a, **k): return False
            def listdir(self, *a, **k): return []
        azure_mod.AzureDB = AzureDB
        azure_mod.AzureSearchIndex = AzureSearchIndex
        azure_mod.AzureADLS = AzureADLS

        # ingestion
        ingestion_mod = ModuleType("KMAI.ingestion")
        class DocumentRetrieval:  # pragma: no cover
            def __init__(self, *_, **__): ...
            def fetch(self, *a, **k): return []
        class Pdf2Markdown:
            def __init__(self, *_, **__): ...
            def convert(self, *a, **k): return "# stub md"
        class Excel2Markdown:
            def __init__(self, *_, **__): ...
            def convert(self, *a, **k): return "# stub table md"
        class Ppt2Markdown:
            def __init__(self, *_, **__): ...
            def convert(self, *a, **k): return "# stub ppt md"
        class DocumentList:
            def __init__(self, *_, **__): ...
            def get_urls_by_hash(self, *a, **k): return []
            def get_urls(self, *a, **k): return []
            def enrich(self, *a, **k): return []
        class TDCertificate:
            def __init__(self, *_, **__): ...
            def validate(self, *a, **k): return True
        ingestion_mod.DocumentRetrieval = DocumentRetrieval
        ingestion_mod.Pdf2Markdown = Pdf2Markdown
        ingestion_mod.Excel2Markdown = Excel2Markdown
        ingestion_mod.Ppt2Markdown = Ppt2Markdown
        ingestion_mod.DocumentList = DocumentList
        ingestion_mod.TDCertificate = TDCertificate

        # processing
        processing_mod = ModuleType("KMAI.processing")
        class KMAIDocumentProcessing:
            def __init__(self, *_, **__): ...
            def process(self, *a, **k): ...
            def clean_markdown(self, s): return s
            def postprocess(self, s): return s
        class DocumentSplit:
            def __init__(self, *_, **__): ...
            def split(self, *a, **k): return []
        class ArchiveProcessing:
            def __init__(self, *_, **__): ...
            def export_document_list(self, *a, **k): ...
            def archive_raw_files(self, *a, **k): ...
            def archive_md_files(self, *a, **k): ...
            def upload_to_adls(self, *a, **k): ...
            def check_index(self, *a, **k): return True
        processing_mod.KMAIDocumentProcessing = KMAIDocumentProcessing
        processing_mod.DocumentSplit = DocumentSplit
        processing_mod.ArchiveProcessing = ArchiveProcessing

        # utilities
        utilities_mod = ModuleType("KMAI.utilities")
        def read_config(*a, **k): return {}
        def read_json_config(*a, **k): return {}
        utilities_mod.read_config = read_config
        utilities_mod.read_json_config = read_json_config

        # wire
        kmai_pkg.azure = azure_mod
        kmai_pkg.ingestion = ingestion_mod
        kmai_pkg.processing = processing_mod
        kmai_pkg.utilities = utilities_mod
        sys.modules.update({
            "KMAI": kmai_pkg,
            "KMAI.azure": azure_mod,
            "KMAI.ingestion": ingestion_mod,
            "KMAI.processing": processing_mod,
            "KMAI.utilities": utilities_mod,
        })
        return

    # If real KMAI is present, augment any missing pieces referenced by tests
    import importlib
    KMAI = importlib.import_module("KMAI")
    def _ensure_submodule(name: str) -> ModuleType:
        full = f"KMAI.{name}"
        mod = sys.modules.get(full)
        if mod is None:
            mod = ModuleType(full)
            setattr(KMAI, name.split(".")[0], mod)
            sys.modules[full] = mod
        return mod
    proc = _ensure_submodule("processing")
    util = _ensure_submodule("utilities")
    if not hasattr(proc, "ArchiveProcessing"):
        class ArchiveProcessing:
            def __init__(self, *_, **__): ...
            def export_document_list(self, *a, **k): ...
            def archive_raw_files(self, *a, **k): ...
            def archive_md_files(self, *a, **k): ...
            def upload_to_adls(self, *a, **k): ...
            def check_index(self, *a, **k): return True
        proc.ArchiveProcessing = ArchiveProcessing
    if not hasattr(util, "read_json_config"):
        def read_json_config(*a, **k): return {}
        util.read_json_config = read_json_config

_ensure_kmai_ok()

# ======================= usecase stub (if absent) ====================
def _ensure_usecase_stub():
    if importlib.util.find_spec("usecase") is not None:
        return
    prod_pkg = ModuleType("usecase.prod")
    common_pkg = ModuleType("usecase.prod.common")
    dataclasses_mod = ModuleType("usecase.prod.common.dataclasses")

    @dataclass
    class IngestionConfig:
        source: str = ""
        params: Dict[str, Any] = field(default_factory=dict)

    @dataclass
    class DocumentWithMetadata:
        content: str = ""
        metadata: Dict[str, Any] = field(default_factory=dict)

    dataclasses_mod.IngestionConfig = IngestionConfig
    dataclasses_mod.DocumentWithMetadata = DocumentWithMetadata

    usecase_pkg = ModuleType("usecase")
    usecase_pkg.prod = prod_pkg
    prod_pkg.common = common_pkg
    common_pkg.dataclasses = dataclasses_mod

    sys.modules.update({
        "usecase": usecase_pkg,
        "usecase.prod": prod_pkg,
        "usecase.prod.common": common_pkg,
        "usecase.prod.common.dataclasses": dataclasses_mod,
    })

_ensure_usecase_stub()

# ======================= pyodbc shim ================================
class _MockCursor:
    def execute(self, *a, **k): ...
    def fetchone(self): return ("15.0.2000.5",)
    def setinputsizes(self, *a, **k): ...
    @property
    def description(self): return [("ProductVersion", None, None, None, None)]
    def rowcount(self): ...
    def close(self): ...

class _MockConnection:
    def cursor(self): return _MockCursor()
    def add_output_converter(self, *a, **k): ...
    def rollback(self): ...
    def commit(self): ...
    def getinfo(self, info):
        if info == 2:  # SQL_DBMS_VER
            return "15.0.2000.5"

class _MockImporter:
    def find_spec(self, fullname, path=None, target=None):
        if fullname == "pyodbc":
            mod = ModuleType("pyodbc")
            mod.__loader__ = MagicMock()
            mod.__package__ = ""
            mod.__spec__ = MagicMock()
            mod.version = "4.0.30"
            mod.connect = MagicMock(return_value=_MockConnection())
            mod.paramstyle = "qmark"
            mod.Cursor = _MockCursor
            mod.Error = Exception
            mod.ProgrammingError = Exception
            mod.SQL_DBMS_VER = 2
            mod.NUMBER = 1
            mod.SQL_VARCHAR = "12"
            mod.DATETIME = "93"
            sys.modules[fullname] = mod
            return mod.__spec__
        return None

sys.meta_path.insert(0, _MockImporter())

# ======================= helpers & fixtures =========================
def get_test_file_path(current_file, target_folder="wkmai-wgpt-etl"):
    absolute_path = os.path.abspath(current_file)
    parts = absolute_path.split(os.sep)
    if target_folder not in parts:
        raise ValueError(f"{target_folder} not in path: {absolute_path}")
    idx = len(parts) - 1 - parts[::-1].index(target_folder)
    out = parts[: idx + 1]
    if "tests" in parts:
        out += parts[parts.index("tests") + 1 :]
    else:
        out += parts[idx + 1 :]
    out = [p[5:] if p.startswith("test_") else p for p in out]
    return os.sep.join(out)

@pytest.fixture
def import_module():
    def _import_module(module_name, file_path):
        spec = importlib.util.spec_from_file_location(module_name, get_test_file_path(file_path))
        mod = importlib.util.module_from_spec(spec)
        sys.modules[module_name] = mod
        spec.loader.exec_module(mod)
        return mod
    return _import_module

@pytest.fixture(scope="session", autouse=True)
def mock_os_environ(tmp_path_factory):
    """
    *** Key fix for EDP ***
    Use a writable temp root instead of /app1/ingestion and create logs dir eagerly.
    """
    test_root = tmp_path_factory.mktemp("ingestion_root")
    project_repo = os.environ.get("PROJECT_REPO", "wgpt-etl")

    env = {
        "KMAI_VERSION": os.environ.get("KMAI_VERSION", "1.0.4"),
        "PROJECT_REPO": project_repo,
        "ROOT_DIR": str(test_root),          # ‚Üê avoid /app1 entirely
        "KMAI_REPO": os.environ.get("KMAI_REPO", "kmai-etl"),
        # Keep any external INGESTION_CONFIG_FILE the pipeline sets.
    }
    with patch.dict(os.environ, env, clear=False):
        logs_dir = Path(os.environ["ROOT_DIR"]) / project_repo / "logs"
        logs_dir.mkdir(parents=True, exist_ok=True)
        yield

@pytest.fixture(scope="session", autouse=True)
def safe_locale():
    import locale
    original = locale.setlocale
    def _safe_setlocale(category, loc=None):
        try:
            return original(category, loc)
        except locale.Error:
            return original(category, "C")
    locale.setlocale = _safe_setlocale
    try:
        yield
    finally:
        locale.setlocale = original

@pytest.fixture(scope="session", autouse=True)
def patch_wgpt_document_processing():
    try:
        from WGPT import document_processing as _dp
        cls = getattr(_dp, "DocumentProcessing", None)
        if not cls:
            return
        def _identity(self, s): return s
        for name in ("naco_doc_preprocess", "naco_doc_basic_clean_html", "naco_doc_post_clean_md"):
            if not hasattr(cls, name):
                setattr(cls, name, _identity)
    except Exception:
        pass

@pytest.fixture
def mock_db():
    db = MagicMock()
    db.executeQuery = MagicMock()
    db.read_sql = MagicMock(return_value=([], []))
    db.execute_insert = MagicMock()
    db.__enter__.return_value = db
    return db
