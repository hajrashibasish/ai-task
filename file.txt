def main_loop():
    config = WGPT.Utilities.read_config()
    server_name = config['sql_db']['server_name']
    db_name = config['sql_db']['db_name']
    etl_schema = config['sql_db']['etl_schema']
    object_id = config['credentials']['object_id']
    document_scopes = config['document_scopes']

    azure_loggers = [
        "azure.identity._credentials.managed_identity",
        "azure.core.pipeline.policies.http_logging_policy"
    ]
    for azl in azure_loggers:
        azlogger = logging.getLogger(azl)
        azlogger.setLevel(logging.ERROR)

    logging.basicConfig(filename=f"{log_file_path}", format="%(levelname)s:%(asctime)s:%(name)s:[DocConversion] %(message)s", level=logging.INFO)

    logger = logging.getLogger("__doc_conversion__")

    for classification in document_scopes.get("classification"):
        for language in document_scopes.get("language"):
            process_doc_conversion(language, classification, logger)


if __name__ == "__main__":
    main_loop()






import pytest
from unittest.mock import patch, MagicMock
import os


@pytest.fixture
def load_module(import_module):
    """Helper to load the doc_conversion module with mocked env."""
    os.environ["KMAI_VERSION"] = "dev"
    os.environ["PROJECT_REPO"] = "wgpt-etl"
    os.environ["ROOT_DIR"] = "/app1/ingestion"
    os.environ["KMAI_REPO"] = "kmai"
    os.environ["INGESTION_CONFIG_FILE"] = "wgpt-etl-dev.json"
    return import_module("doc_conversion", os.path.abspath(__file__))


def test_process_doc_conversion_html(load_module):
    logger = MagicMock()
    config_mock = {
        "processing": {
            "output_dir": "/tmp/output",
            "md_dir": "/tmp/md"
        },
        "sql_db": {
            "etl_schema": "etl",
            "server_name": "srv",
            "db_name": "db"
        },
        "credentials": {
            "object_id": "xyz"
        },
        "document_scopes": {
            "classification": ["internal"],
            "language": ["en"],
            "filter_columns": {"key": "value"}
        },
        "failed_document_threshold_pct": 1.0
    }

    urls_mock = {
        "internal": {
            "en": {
                "http://example.com/doc1.html": {"doc_id": "doc1"}
            }
        }
    }

    os_walk_return = [
        ("/tmp/output/internal/en", [], ["doc1.html"])
    ]

    with patch.object(load_module.WGPT.Utilities, "read_config", return_value=config_mock), \
         patch.object(load_module, "retrieve_url_list", return_value=urls_mock), \
         patch.object(load_module, "os") as mock_os, \
         patch.object(load_module, "process_html_to_markdown", return_value={"status": "Successful"}):
        mock_os.walk.return_value = os_walk_return
        mock_os.path.exists.return_value = True
        mock_os.remove = MagicMock()
        mock_os.makedirs = MagicMock()
        result = load_module.process_doc_conversion("en", "internal", logger)
        assert result is not None


@patch("builtins.open", new_callable=MagicMock)
def test_process_html_to_markdown_success(mock_open, load_module):
    fake_text = "<html><body><h1>Hello</h1></body></html>"
    fake_output = "## Hello"
    logger = MagicMock()



==================


def test_process_doc_conversion_html(load_module):
    logger = MagicMock()

    config_mock = {
        "processing": {
            "output_dir": "/tmp/output",
            "md_dir": "/tmp/md"
        },
        "sql_db": {
            "etl_schema": "etl",
            "server_name": "srv",
            "db_name": "db"
        },
        "credentials": {
            "object_id": "xyz"
        },
        "document_scopes": {
            "classification": ["internal"],
            "language": ["en"],
            "filter_columns": {"key": "value"}
        },
        "failed_document_threshold_pct": 1.0
    }

    urls_mock = {
        "internal": {
            "en": {
                "doc1": {"doc_id": "doc1", "url": "http://example.com/doc1.html"}
            }
        }
    }

    os_walk_return = [
        ("/tmp/output/internal/en", [], ["doc1.html"])
    ]

    with patch.object(load_module.WGPT.Utilities, "read_config", return_value=config_mock), \
         patch.object(load_module, "retrieve_url_list", return_value=urls_mock), \
         patch.object(load_module, "os") as mock_os, \
         patch.object(load_module, "process_html_to_markdown", return_value={"status": "Successful"}):

        mock_os.walk.return_value = os_walk_return
        mock_os.path.exists.return_value = True
        mock_os.remove = MagicMock()
        mock_os.makedirs = MagicMock()
        mock_os.path.splitext = os.path.splitext

        result = load_module.process_doc_conversion("en", "internal", logger)
        print("Returned result", result)

        assert result == {"doc1": {"status": "Successful"}}


    mock_fd = MagicMock()
    mock_fd.read.return_value = fake_text
    mock_open.return_value.__enter__.side_effect = [mock_fd, MagicMock()]
    dp_mock = MagicMock()
    dp_mock.run_pipeline.return_value = fake_output

    with patch.object(load_module, "DocumentProcessing", return_value=dp_mock):
        result = load_module.process_html_to_markdown("/tmp/file.html", "/tmp", "en", {})
        assert result["status"] == "Successful"
        assert "document_length" in result


def test_process_pdf_to_markdown(load_module):
    config = {
        "credentials": {"client_id": "abc"},
        "open_ai": {
            "gpt_4o_model": "gpt",
            "endpoint_url": "https://xyz",
            "openai_api_version": "v1",
            "pdf_conversion_prompt": "convert",
            "pdf_conversion_dpi": 300
        }
    }
    dp_mock = MagicMock()
    dp_mock.run_pipeline.return_value = "PDF to MD content"
    with patch.object(load_module, "DocumentProcessing", return_value=dp_mock):
        result = load_module.process_pdf_to_markdown(config, "/tmp/doc.pdf", "/tmp", {})
        assert result["document_length"] > 0


def test_process_excel_to_markdown(load_module):
    config = {}
    dp_mock = MagicMock()
    dp_mock.run_pipeline.return_value = "Excel to Markdown"
    with patch.object(load_module, "DocumentProcessing", return_value=dp_mock):
        result = load_module.process_excel_to_markdown(config, "/tmp/excel.xlsx", "/tmp", {})
        assert result["document_length"] > 0


def test_process_ppt_to_markdown(load_module):
    return_val = {}
    ppt_mock = MagicMock()
    ppt_mock.convert.return_value = ("/tmp/doc.md", 1000)
    with patch.object(load_module, "Ppt2Markdown", return_value=ppt_mock):
        result = load_module.process_ppt_to_markdown("/tmp/file.pptx", "/tmp", return_val)
        assert result["status"] == "Successful"
        assert result["document_length"] == 1000










====================

import pytest
from unittest.mock import patch, MagicMock, mock_open
import os

@pytest.fixture
def load_module(import_module):
    """Helper to dynamically load doc_conversion.py with env vars."""
    os.environ["KMAI_VERSION"] = "dev"
    os.environ["PROJECT_REPO"] = "wgpt-etl"
    os.environ["ROOT_DIR"] = "/app1/ingestion"
    os.environ["KMAI_REPO"] = "kmai"
    os.environ["INGESTION_CONFIG_FILE"] = "wgpt-etl-dev.json"
    return import_module("doc_conversion", os.path.abspath(__file__))


def test_retrieve_url_list(load_module):
    mock_db = MagicMock()

    # Mock config
    mock_read_config = MagicMock(return_value={
        "sql_db": {
            "server_name": "test_server",
            "db_name": "test_db",
            "etl_schema": "etl"
        },
        "credentials": {"object_id": "test_object_id"},
        "document_scopes": {"filter_columns": {"key": "value"}}
    })

    # Mock DocumentList
    mock_doclist = MagicMock()
    mock_doclist_instance = MagicMock()
    mock_doclist_instance.get_urls.return_value = {"url1": "metadata1"}
    mock_doclist.return_value = mock_doclist_instance

    with patch.object(load_module, "WGPT") as mock_wgpt, \
         patch.object(load_module, "AzureDB", return_value=mock_db), \
         patch.object(load_module, "DocumentList", mock_doclist):

        mock_wgpt.Utilities.read_config = mock_read_config

        result = load_module.retrieve_url_list("classification", "language", MagicMock(), "etl")

        assert result == {"url1": "metadata1"}
        mock_doclist_instance.get_urls.assert_called_once_with(
            {
                "classification": "classification",
                "language": "language",
                "active_flag": "Y",
                "etl_schema": "etl",
                "key": "value"
            },
            None
        )


@patch("builtins.open", new_callable=mock_open, read_data="<html>content</html>")
def test_process_html_to_markdown(mock_open, load_module):
    mock_document_processing = MagicMock()
    mock_dp_instance = MagicMock()
    mock_dp_instance.run_pipeline.return_value = "markdown content"
    mock_document_processing.return_value = mock_dp_instance

    file_path = "/path/to/file.html"
    output_dir = "/output"
    language = "en"
    return_values = {}

    with patch.object(load_module, "DocumentProcessing", mock_document_processing):
        result = load_module.process_html_to_markdown(file_path, output_dir, language, return_values)

        assert result["status"] == "Successful"
        assert result["document_length"] == len("markdown content")

        mock_open.assert_any_call(file_path, "r")
        mock_open.assert_any_call(f"{output_dir}/file.md", "w")
        mock_dp_instance.run_pipeline.assert_called_once_with(
            input_data="<html>content</html>",
            paragraph=True,
            link=True,
            language=language,
            return_value=return_values
        )

