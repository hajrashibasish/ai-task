import pytest
from unittest.mock import patch, MagicMock, mock_open
import os
import json
import requests
import builtins
import pandas as pd
from pathlib import Path

# Helper setup to simulate env and import
@pytest.fixture(scope="module")
def setup_module():
    os.environ["KMAI_VERSION"] = "1.0.3"
    os.environ["KMAI_REPO"] = "kmai-etl"
    os.environ["PROJECT_REPO"] = "wgpt-etl"
    os.environ["ROOT_DIR"] = "/app1/ingestion"
    return True

# Test load_doc_id_map
@patch("builtins.open", new_callable=mock_open, read_data='{"http://example.com": {"DOC_ID": "X123"}}')
@patch("os.path.exists", return_value=True)
def test_load_doc_id_map_exists(mock_exists, mock_open_file):
    from bin import 01_downloadfiles as module
    result = module.load_doc_id_map("/mock/log", "en")
    assert result == {"http://example.com": {"DOC_ID": "X123"}}

@patch("os.path.exists", return_value=False)
def test_load_doc_id_map_missing(mock_exists):
    from bin import 01_downloadfiles as module
    result = module.load_doc_id_map("/mock/log", "fr")
    assert result == {}

# Test retrieve_url_list for missing classification/language
@patch("KMAI.ingestion.DocumentList.get_urls")
def test_retrieve_url_list_missing_classification(mock_get_urls):
    from bin import 01_downloadfiles as module
    mock_get_urls.return_value = {"internal": {"fr": {}}}  # 'en' missing intentionally
    doc_list = MagicMock()
    result = module.retrieve_url_list("internal", "en", doc_list, MagicMock(), None, "etl", {})
    assert result == {}

@patch("KMAI.ingestion.DocumentList.get_urls")
def test_retrieve_url_list_missing_language(mock_get_urls):
    from bin import 01_downloadfiles as module
    mock_get_urls.return_value = {"internal": {}}  # language missing
    doc_list = MagicMock()
    result = module.retrieve_url_list("internal", "en", doc_list, MagicMock(), None, "etl", {})
    assert result == {}

# Test XLSX download and processing
@patch("builtins.open", new_callable=mock_open)
@patch("requests.get")
@patch("WGPT.MetadataProcessing.save_metadata_binary")
def test_process_xlsx_entry(mock_save, mock_get, mock_open_file):
    from bin import 01_downloadfiles as module
    mock_get.return_value.iter_content = lambda chunk_size: [b"fake_xlsx_data"]
    mock_get.return_value.raise_for_status = lambda: None
    mock_get.return_value.status_code = 200

    entry = {"url": "http://example.com/sample.xlsx", "doc_id": "DOCX1"}
    config = {
        "sql_db": {"etl_schema": "etl"},
        "processing": {"log_dir": "/tmp"}
    }
    os.makedirs("/tmp/test", exist_ok=True)
    module.process_xlsx_entry(entry, "internal", "en", "/tmp/test", MagicMock(), config)
    assert mock_save.called

# Test PPT download and processing
@patch("builtins.open", new_callable=mock_open)
@patch("requests.get")
@patch("WGPT.MetadataProcessing.save_metadata_binary")
def test_process_ppt_entry(mock_save, mock_get, mock_open_file):
    from bin import 01_downloadfiles as module
    mock_get.return_value.iter_content = lambda chunk_size: [b"fake_ppt_data"]
    mock_get.return_value.raise_for_status = lambda: None
    mock_get.return_value.headers = {}

    entry = {"url": "http://example.com/sample.pptx", "doc_id": "PPT123"}
    config = {
        "sql_db": {"etl_schema": "etl"},
        "processing": {"log_dir": "/tmp"}
    }
    os.makedirs("/tmp/test/images", exist_ok=True)
    module.process_ppt_entry(entry, "public", "fr", "/tmp/test", MagicMock(), config)
    assert mock_save.called

# Minimal test for download_files orchestration (fully mocked)
@patch("bin.01_downloadfiles.retrieve_url_list")
@patch("bin.01_downloadfiles.DocumentRetrieval.retrieve")
@patch("bin.01_downloadfiles.WGPT.MetadataProcessing.save_metadata_binary")
@patch("os.makedirs")
@patch("os.path.exists", return_value=False)
@patch("builtins.open", new_callable=mock_open)
def test_download_files(mock_open_file, mock_exists, mock_makedirs, mock_save, mock_retrieve, mock_get_urls):
    from bin import 01_downloadfiles as module
    mock_get_urls.side_effect = [
        {"internal": {"en": {"http://ppt.com": {"doc_type": "pptx", "doc_id": "PPT1", "url": "http://ppt.com"}}}},
        {"internal": {"en": {"http://xls.com": {"doc_type": "xlsx", "doc_id": "XLS1", "url": "http://xls.com"}}}}
    ]
    mock_retrieve.return_value = {
        "http://other.com": {
            "path": "/tmp/sample.txt",
            "type": "text",
            "status": "success",
            "doc_id": "TXT1"
        }
    }

    config = {
        "sql_db": {"etl_schema": "etl"},
        "processing": {"output_dir": "/tmp/test", "log_dir": "/tmp"},
        "max_url_retries": 2
    }

    monkeypatch = MagicMock()
    monkeypatch.setattr(module.WGPT.Utilities, "read_config", lambda: config)

    db = MagicMock()
    module.download_files("internal", "en", db)
    assert mock_save.called or mock_retrieve.called
