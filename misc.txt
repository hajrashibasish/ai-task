# tests/conftest.py
import os
import sys
import importlib.util
from pathlib import Path
from types import ModuleType
from unittest.mock import MagicMock, patch
import pytest

# -------------------- WGPT path bootstrap (bin/lib or bin/libs) --------------------
def _find_repo_root(start: Path, markers=("wkmai-wgpt-etl", "wgpt-etl")) -> Path:
    parts = start.parts
    idxs = [i for i, p in enumerate(parts) if p in markers]
    if idxs:
        return Path(*parts[: idxs[-1] + 1])
    for p in [start, *start.parents]:
        if (p / "bin" / "lib" / "WGPT").is_dir() or (p / "bin" / "libs" / "WGPT").is_dir():
            return p
    raise RuntimeError(f"Could not locate repo root from: {start}")

def _add_wgpt_parent_to_syspath(current_file: str) -> None:
    here = Path(current_file).resolve()
    repo_root = _find_repo_root(here)
    for cand in (repo_root / "bin" / "lib", repo_root / "bin" / "libs"):
        if (cand / "WGPT").is_dir():
            s = str(cand)
            if s not in sys.path:
                sys.path.insert(0, s)  # parent of WGPT
            return
    raise ImportError("WGPT not found under bin/lib or bin/libs")

_add_wgpt_parent_to_syspath(__file__)

# -------------------- KMAI full stub (only if real KMAI is absent) --------------------
def _ensure_kmai_stub():
    spec = importlib.util.find_spec("KMAI")
    if spec is not None:
        return  # real KMAI exists (e.g., on your VM) â€“ do nothing

    # Top-level package
    kmai_pkg = ModuleType("KMAI")

    # ---- KMAI.azure ----
    azure_mod = ModuleType("KMAI.azure")

    class AzureDB:
        def __init__(self, *args, **kwargs): pass
        def __enter__(self): return self
        def __exit__(self, exc_type, exc, tb): pass
        # Common helpers used in tests; safe no-ops
        def executeQuery(self, *a, **k): return []
        def read_sql(self, *a, **k): return ([], [])
        def execute_insert(self, *a, **k): return None

    class AzureSearchIndex:
        def __init__(self, *args, **kwargs): pass
        def upsert(self, *a, **k): return None
        def search(self, *a, **k): return []

    class AzureADLS:
        def __init__(self, *args, **kwargs): pass
        def upload(self, *a, **k): return None
        def download(self, *a, **k): return b""
        def exists(self, *a, **k): return False
        def listdir(self, *a, **k): return []

    azure_mod.AzureDB = AzureDB
    azure_mod.AzureSearchIndex = AzureSearchIndex
    azure_mod.AzureADLS = AzureADLS

    # ---- KMAI.ingestion ----
    ingestion_mod = ModuleType("KMAI.ingestion")

    class DocumentRetrieval:
        def __init__(self, *args, **kwargs): pass
        def fetch(self, *a, **k): return []

    class Pdf2Markdown:
        def __init__(self, *args, **kwargs): pass
        def convert(self, *a, **k): return "# stub md"

    class DocumentList:
        def __init__(self, *args, **kwargs): pass
        def get_urls_by_hash(self, *a, **k): return []
        def get_urls(self, *a, **k): return []
        def enrich(self, *a, **k): return []

    class Excel2Markdown:
        def __init__(self, *args, **kwargs): pass
        def convert(self, *a, **k): return "# stub table md"

    class TDCertificate:
        def __init__(self, *args, **kwargs): pass
        def validate(self, *a, **k): return True

    ingestion_mod.DocumentRetrieval = DocumentRetrieval
    ingestion_mod.Pdf2Markdown = Pdf2Markdown
    ingestion_mod.DocumentList = DocumentList
    ingestion_mod.Excel2Markdown = Excel2Markdown
    ingestion_mod.TDCertificate = TDCertificate

    # ---- KMAI.processing ----
    processing_mod = ModuleType("KMAI.processing")

    class KMAIDocumentProcessing:
        def __init__(self, *args, **kwargs): pass
        def process(self, *a, **k): return None
        def clean_markdown(self, s): return s
        def postprocess(self, s): return s

    class DocumentSplit:
        def __init__(self, *args, **kwargs): pass
        def split(self, *a, **k): return []

    processing_mod.KMAIDocumentProcessing = KMAIDocumentProcessing
    processing_mod.DocumentSplit = DocumentSplit

    # ---- KMAI.utilities ----
    utilities_mod = ModuleType("KMAI.utilities")

    def read_config(*args, **kwargs):
        # Safe default; tests should patch as needed
        return {}

    utilities_mod.read_config = read_config

    # Wire up the package
    kmai_pkg.azure = azure_mod
    kmai_pkg.ingestion = ingestion_mod
    kmai_pkg.processing = processing_mod
    kmai_pkg.utilities = utilities_mod

    sys.modules["KMAI"] = kmai_pkg
    sys.modules["KMAI.azure"] = azure_mod
    sys.modules["KMAI.ingestion"] = ingestion_mod
    sys.modules["KMAI.processing"] = processing_mod
    sys.modules["KMAI.utilities"] = utilities_mod

_ensure_kmai_stub()

# -------------------- pyodbc shim --------------------
class _MockCursor:
    def execute(self, *a, **k): pass
    def fetchone(self): return ("15.0.2000.5",)
    def setinputsizes(self, *a, **k): return
    @property
    def description(self): return [("ProductVersion", None, None, None, None)]
    def rowcount(self): return
    def close(self): pass

class _MockConnection:
    def cursor(self): return _MockCursor()
    def add_output_converter(self, *a, **k): pass
    def rollback(self): pass
    def commit(self): pass
    def getinfo(self, info):
        if info == 2:  # SQL_DBMS_VER
            return "15.0.2000.5"

class _MockImporter:
    def find_spec(self, fullname, path=None, target=None):
        if fullname == "pyodbc":
            mod = ModuleType("pyodbc")
            mod.__loader__ = MagicMock()
            mod.__package__ = ""
            mod.__spec__ = MagicMock()
            mod.version = "4.0.30"
            mod.connect = MagicMock(return_value=_MockConnection())
            mod.paramstyle = "qmark"
            mod.Cursor = _MockCursor
            mod.Error = Exception
            mod.ProgrammingError = Exception
            mod.SQL_DBMS_VER = 2
            mod.NUMBER = 1
            mod.SQL_VARCHAR = "12"
            mod.DATETIME = "93"
            sys.modules[fullname] = mod
            return mod.__spec__
        return None

sys.meta_path.insert(0, _MockImporter())

# -------------------- helpers & fixtures --------------------
def get_test_file_path(current_file, target_folder="wkmai-wgpt-etl"):
    absolute_path = os.path.abspath(current_file)
    parts = absolute_path.split(os.sep)
    if target_folder not in parts:
        raise ValueError(f"{target_folder} not in path: {absolute_path}")
    idx = len(parts) - 1 - parts[::-1].index(target_folder)
    out = parts[: idx + 1]
    if "tests" in parts:
        out += parts[parts.index("tests") + 1 :]
    else:
        out += parts[idx + 1 :]
    out = [p[5:] if p.startswith("test_") else p for p in out]
    return os.sep.join(out)

@pytest.fixture
def import_module():
    def _import_module(module_name, file_path):
        spec = importlib.util.spec_from_file_location(module_name, get_test_file_path(file_path))
        mod = importlib.util.module_from_spec(spec)
        sys.modules[module_name] = mod
        spec.loader.exec_module(mod)
        return mod
    return _import_module

@pytest.fixture(scope="session", autouse=True)
def mock_os_environ():
    with patch.dict(os.environ, {
        "KMAI_VERSION": os.environ.get("KMAI_VERSION", "1.0.4"),
        "PROJECT_REPO": os.environ.get("PROJECT_REPO", "wgpt-etl"),
        "ROOT_DIR": os.environ.get("ROOT_DIR", "/app1/ingestion"),
        "KMAI_REPO": os.environ.get("KMAI_REPO", "kmai-etl"),
    }, clear=False):
        yield

@pytest.fixture
def mock_db():
    db = MagicMock()
    db.executeQuery = MagicMock()
    db.read_sql = MagicMock(return_value=([], []))
    db.execute_insert = MagicMock()
    db.__enter__.return_value = db
    return db
