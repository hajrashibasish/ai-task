import pytest
from unittest.mock import patch, MagicMock
import os


@pytest.fixture
def load_module(import_module):
    load_module = import_module("doc_conversion", os.path.abspath(__file__))
    return load_module


def test_process_doc_conversion_unsupported_filetype(load_module):
    # Only required config fields for the main script logic
    config_mock = {
        "processing": {
            "log_dir": "/tmp/logs",
            "output_dir": "/tmp/output",
            "md_dir": "/tmp/md"
        },
        "sql_db": {
            "server_name": "localhost",
            "db_name": "test_db",
            "etl_schema": "etl"
        }
    }

    urls_mock = {"file.unsupported": {"document_id": "123"}}
    os_walk_return = [
        ("/tmp/output/internal/en", [], ["file.unsupported"])
    ]

    with patch.object(load_module.WGPT.Utilities, "read_config", return_value=config_mock), \
         patch.object(load_module, "retrieve_url_list", return_value=urls_mock), \
         patch.object(load_module, "os") as mock_os:

        mock_os.walk.return_value = os_walk_return
        mock_os.path.exists.return_value = True
        mock_os.remove = MagicMock()
        mock_os.makedirs = MagicMock()
        mock_os.path.splitext = os.path.splitext

        result = load_module.process_doc_conversion("en", "internal", MagicMock())
        assert result == {"file.unsupported": {"status": "unsupported file type"}}



    config_mock = {
        "processing": {
            "log_dir": "/tmp/logs",
            "output_dir": "/tmp/output",
            "md_dir": "/tmp/md"
        },
        "sql_db": {
            "etl_schema": "mock_schema"
        }
    }

    classification = "internal"
    language = "en"

    # Properly structured urls mock as expected in main script
    urls_mock = {
        classification: {
            language: [
                {
                    "file": "doc1.xyz",
                    "status": "pending",
                    "output_dir": f"/tmp/output/{classification}/{language}",
                    "language": language
                }
            ]
        }
    }

    # Simulate os.walk to detect 1 file
    os_walk_return = [
        (f"/tmp/output/{classification}/{language}", [], ["doc1.xyz"])
    ]

    with patch.object(load_module.WGPT.Utilities, "read_config", return_value=config_mock), \
         patch.object(load_module, "retrieve_url_list", return_value=urls_mock), \
         patch.object(load_module, "os") as mock_os:

        # Patch os-related operations
        mock_os.walk.return_value = os_walk_return
        mock_os.path.exists.return_value = True
        mock_os.remove = MagicMock()
        mock_os.makedirs = MagicMock()
        mock_os.path.splitext = os.path.splitext
        mock_os.path.join = os.path.join

        result = load_module.process_doc_conversion("en", "internal", MagicMock())
        assert result == {"file.unsupported": {"status": "unsupported file type"}}



def test_process_doc_conversion_unsupported_filetype(load_module):
    config_mock = {
        "processing": {
            "log_dir": "/tmp/logs",
            "output_dir": "/tmp/output",
            "md_dir": "/tmp/md"
        },
        "sql_db": {
            "etl_schema": "mock_schema"
        },
        "failed_document_threshold_pct": 0.5
    }

    # Use hardcoded classification and language
    classification = "internal"
    language = "en"
    test_filename = "file.xyz"

    urls_mock = {
        "internal": {
            "en": [
                {
                    "file": "file.xyz",
                    "status": "pending",
                    "output_dir": "/tmp/output/internal/en",
                    "language": "en"
                }
            ]
        }
    }

    os_walk_return = [
        ("/tmp/output/internal/en", [], ["file.xyz"])
    ]

    with patch.object(load_module.WGPT.Utilities, "read_config", return_value=config_mock), \
         patch.object(load_module, "retrieve_url_list", return_value=urls_mock), \
         patch.object(load_module, "os") as mock_os:

        mock_os.walk.return_value = os_walk_return
        mock_os.path.exists.return_value = True
        mock_os.remove = MagicMock()
        mock_os.makedirs = MagicMock()
        mock_os.path.splitext = os.path.splitext
        mock_os.path.join = os.path.join

        result = load_module.process_doc_conversion("en", "internal", MagicMock())

        assert result == {
            "file": {"status": "unsupported file type"}
        }

