import pytest
from unittest.mock import patch, MagicMock, mock_open
import os
import json

@pytest.fixture
def load_module(import_module):
    """Helper to dynamically import the module with mocked os.environ."""
    return import_module("generatemetajson", os.path.abspath(__file__))

@pytest.fixture
def mock_config():
    return {
        "sql_db": {
            "server_name": "mock_server",
            "db_name": "mock_db",
            "etl_schema": "mock_schema"
        },
        "credentials": {
            "object_id": "mock_object_id",
            "client_id": "mock_client_id"
        },
        "processing": {
            "log_dir": "/mock/log_dir",
            "md_dir": "/mock/md_dir"
        },
        "document_scopes": {
            "language": ["en", "fr"],
            "filter_columns": {"key1": "value1"}
        },
        "adls_storage": {
            "storage_account": "mock_storage",
            "container_names": {
                "en": "container-en",
                "fr": "container-fr"
            },
            "target_directory_metadata": {
                "en": "/mock/target/en",
                "fr": "/mock/target/fr"
            }
        }
    }

def test_generate_meta_json_success(load_module, mock_config):
    with patch.object(load_module.WGPT.Utilities, "read_config", return_value=mock_config), \
         patch.object(load_module, "AzureDB") as mock_azure_db, \
         patch.object(load_module, "AzureADLS") as mock_azure_adls, \
         patch.object(load_module, "DocumentList") as mock_document_list, \
         patch("builtins.open", new_callable=mock_open), \
         patch("os.rename"), \
         patch("json.dump"), \
         patch("os.path.dirname", return_value="/mock/dir"), \
         patch.object(load_module, "enrich_with_flags", side_effect=lambda m, *_: m), \
         patch.dict(os.environ, {
             "KMAI_VERSION": "1.0.1",
             "PROJECT_REPO": "project_repo",
             "KMAI_REPO": "kmai_repo",
             "ROOT_DIR": "/test"
         }, clear=True):

        # Mock return values for AzureDB and ADLS
        mock_azure_db.return_value.__enter__.return_value = MagicMock()
        mock_adls_instance = mock_azure_adls.return_value
        mock_adls_instance.getDirectoryListing.return_value = []

        # Set up separate instances for each DocumentList call
        instance1 = MagicMock()
        instance2 = MagicMock()
        instance1.generate_metajson.return_value = {"mock_key1": {"url": "http://x1"}}
        instance2.generate_metajson.return_value = {"mock_key2": {"url": "http://x2"}}
        mock_document_list.side_effect = [instance1, instance2]

        # Trigger execution
        load_module.__name__ = "__main__"
        load_module  # simply importing runs the script

        # âœ… Assert both instances had generate_metajson called
        instance1.generate_metajson.assert_called_once()
        instance2.generate_metajson.assert_called_once()

