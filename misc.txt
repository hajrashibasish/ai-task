# tests/conftest.py
import os
import sys
import importlib.util
from pathlib import Path
from types import ModuleType
from unittest.mock import MagicMock, patch
import pytest

# -----------------------------------------------------------------------------
# 1) Make WGPT importable (parent of WGPT on sys.path). Supports bin/lib & bin/libs.
# -----------------------------------------------------------------------------
def _find_repo_root(start: Path, markers=("wkmai-wgpt-etl", "wgpt-etl")) -> Path:
    parts = start.parts
    indices = [i for i, p in enumerate(parts) if p in markers]
    if indices:
        return Path(*parts[: indices[-1] + 1])  # deepest marker (handles nested checkouts)
    # Fallback: walk up until we see bin/lib(s)/WGPT
    for p in [start, *start.parents]:
        if (p / "bin" / "lib" / "WGPT").is_dir() or (p / "bin" / "libs" / "WGPT").is_dir():
            return p
    raise RuntimeError(f"Could not locate repo root from: {start}")

def _add_wgpt_parent_to_syspath(current_file: str) -> None:
    here = Path(current_file).resolve()
    repo_root = _find_repo_root(here)
    for cand in (repo_root / "bin" / "lib", repo_root / "bin" / "libs"):
        if (cand / "WGPT").is_dir():
            s = str(cand)
            if s not in sys.path:
                sys.path.insert(0, s)  # IMPORTANT: add parent of WGPT, not WGPT itself
            return
    raise ImportError(
        "Could not find WGPT package. Expected one of:\n"
        f"  {repo_root}/bin/lib/WGPT  or  {repo_root}/bin/libs/WGPT"
    )

_add_wgpt_parent_to_syspath(__file__)

# -----------------------------------------------------------------------------
# 2) Make KMAI importable from /app1/ingestion/kmai-etl/<version>/libs
#    (mirrors your VM layout exactly)
# -----------------------------------------------------------------------------
ROOT_DIR = os.environ.get("ROOT_DIR", "/app1/ingestion")
KMAI_REPO = os.environ.get("KMAI_REPO", "kmai-etl")
KMAI_VERSION = os.environ.get("KMAI_VERSION", "1.0.4")
KMAI_LIB_PATH = os.path.join(ROOT_DIR, KMAI_REPO, KMAI_VERSION, "libs")  # parent of KMAI

if KMAI_LIB_PATH not in sys.path:
    sys.path.insert(0, KMAI_LIB_PATH)

# -----------------------------------------------------------------------------
# 3) Lightweight pyodbc shim so imports donâ€™t fail in CI/EDP
# -----------------------------------------------------------------------------
class MockCursor:
    def execute(self, *args, **kwargs): pass
    def fetchone(self): return ("15.0.2000.5",)
    def setinputsizes(self, *args, **kwargs): return
    @property
    def description(self): return [("ProductVersion", None, None, None, None)]
    def rowcount(self): return
    def close(self): pass

class MockConnection:
    def cursor(self): return MockCursor()
    def add_output_converter(self, *args, **kwargs): pass
    def rollback(self): pass
    def commit(self): pass
    def getinfo(self, info):
        if info == 2:  # SQL_DBMS_VER
            return "15.0.2000.5"

class MockImporter:
    def find_spec(self, fullname, path=None, target=None):
        if fullname == "pyodbc":
            module = ModuleType("pyodbc")
            module.__loader__ = MagicMock()
            module.__package__ = ""
            module.__spec__ = MagicMock()
            module.version = "4.0.30"
            module.connect = MagicMock(return_value=MockConnection())
            module.paramstyle = "qmark"
            module.Cursor = MockCursor
            module.Error = Exception
            module.ProgrammingError = Exception
            module.SQL_DBMS_VER = 2
            module.NUMBER = 1
            module.SQL_VARCHAR = "12"
            module.DATETIME = "93"
            sys.modules[fullname] = module
            return module.__spec__
        return None

sys.meta_path.insert(0, MockImporter())

# -----------------------------------------------------------------------------
# 4) Helpers & Fixtures
# -----------------------------------------------------------------------------
def get_test_file_path(current_file, target_folder="wkmai-wgpt-etl"):
    absolute_path = os.path.abspath(current_file)
    path_parts = absolute_path.split(os.sep)

    if target_folder not in path_parts:
        raise ValueError(f"Target folder {target_folder} not in path: {absolute_path}")
    wgpt_index = len(path_parts) - 1 - path_parts[::-1].index(target_folder)

    source_path_parts = path_parts[: wgpt_index + 1]

    if "tests" in path_parts:
        tests_index = path_parts.index("tests")
        source_path_parts += path_parts[tests_index + 1 :]
    else:
        source_path_parts += path_parts[wgpt_index + 1 :]

    source_path_parts = [part[5:] if part.startswith("test_") else part for part in source_path_parts]
    return os.sep.join(source_path_parts)

@pytest.fixture
def import_module():
    """Dynamically import a module by name and file path (after prefix munging)."""
    def _import_module(module_name, file_path):
        spec = importlib.util.spec_from_file_location(module_name, get_test_file_path(file_path))
        module = importlib.util.module_from_spec(spec)
        sys.modules[module_name] = module
        spec.loader.exec_module(module)
        return module
    return _import_module

@pytest.fixture(scope="session", autouse=True)
def mock_os_environ():
    """Provide defaults; do NOT clear to preserve EDP-provided vars."""
    mock_env = {
        "KMAI_VERSION": os.environ.get("KMAI_VERSION", "1.0.4"),
        "PROJECT_REPO": os.environ.get("PROJECT_REPO", "wgpt-etl"),
        "ROOT_DIR": os.environ.get("ROOT_DIR", "/app1/ingestion"),
        "KMAI_REPO": os.environ.get("KMAI_REPO", "kmai-etl"),
    }
    with patch.dict(os.environ, mock_env, clear=False):
        yield mock_env

@pytest.fixture
def mock_db():
    mock_db = MagicMock()
    mock_db.executeQuery = MagicMock()
    mock_db.read_sql = MagicMock(return_value=([], []))
    mock_db.execute_insert = MagicMock()
    mock_db.__enter__.return_value = mock_db
    return mock_db
